
--[==[
性能标准
{
	耗时推荐值：FPS 渲染 逻辑代码 UI模块 物理模块 GPU耗时
	内存推荐值：
	{
		Reserved Total: 可以理解为分配总内存
		避免游戏闪退的重点在于控制PSS内存峰值。而PSS内存的大头又在于Reserved Total中的【资源内存和Mono堆内存】。对于使用Lua的项目来说，还应关注Lua内存。

		根据UWA的经验，只有当PSS内存峰值控制在硬件总内存的0.5-0.6倍以下的时候，闪退风险才较低
		举例而言，对于2G的设备而言，PSS内存应控制在1G以下为最佳，3G的设备则应控制在1.5G以下
		而对于大多数项目而言，PSS内存大约高于Reserved Total 200MB-300MB左右，故2G设备的Reserved Total应控制在700MB以下、3G设备则控制在1G以下。

		内存类型
		{
			资源内存
			{
				Texture
				Mesh
				Shader
				Animation Clip
				Audio Clip
				Render Texture
				Font
				ParticleSystem
			}
			Mono堆内存
			Lua内存
		}
	}
}
]==]

--[==[
性能排查工具
{
	Unity Profiler
	Unity FrameDebugger
	Mali Offline Compiler:该工具主要用来计算Shader的复杂度，结合分档的高中低数值来判断Shader是否过于复杂。
	XCode FrameDebugger: 特别强大
	GOT Online
}

]==]

--[==[
策略导致的内存问题
{
	资源冗余: 资源冗余往往是很多项目中最为常见的内存问题之一。而其中往往【AssetBundle打包策略】和【资源加载缓存策略】又是导致冗余的最主要的两种原因
	{
		bundle资源冗余：同样的资源被打了两份造成内存浪费 也会加载多次造成加载时间边长
	}
	代码生成的资源: 运行时通过代码接口生成某些暂时性资源是非常常见的做法，但使用不当也很容易产生性能问题。
	加载和缓存策略:
}


]==]

--------------------------------------Gfx内存---------------------------------------------------------
--[==[

纹理资源内存优化
{
	纹理资源是最常用、也是很多项目中占内存大头的一种资源。它还和项目的渲染模块CPU、GPU性能有很大关联。本节主要从内存角度探讨纹理的格式、分辨率、Read/Write Enabled、Mipmap

	压缩格式
	{
	 	平常存在磁盘上的都是jpg或者png的压缩格式，这些格式只能用于减少图片的磁盘占用空间，无法被GPU识别和读取，
	 	所以无论这些图片在电脑种以什么样的格式存储，在导入Unity的时候都会经过import这个过程转换成纹理的格式（ETC或者 ASTC 能直接被Mobile GPU直接读取）

	 	纹理压缩的目的
	 	{
			节省内存
			减少带宽
			降低加载纹理消耗
	 	}

	 	设备平台不支持的格式Unity会自动回退到RGBA格式

	 	ETC2_8bit 与 ATSC4X4 压缩后大小相同
	 	ETC2_4bit 与 ATSC6X6 压缩后大小相同

	}

	MipMap
	{
		优化远处物体的表现效果
		减少Cache Miss, 减少带宽

		缺点是内存增加1/3

		建议
		{
			2d UI，摄像机距离固定，没有远近变化，应关闭
			3d UI以及其他作用3d渲染的纹理，建议开启
		}
	}

	Texture Quality
	{
		可以显著改变纹理的内存占用==》通过减少加载进内存的Mipmap层数来减少纹理的占用，只针对开启Mipmap的纹理生效
		Editor——Project Settings —— Quality —— Textures
		{
			Full Res :加载所有的Mipmap层级
			Half Res ：排除Mipmap0，其他层级都加载
			Quarter Res: 排除Mipmap0 Mipmap1，其他层级都加载
		}

		可以用来画质分级


	}
	Texture Streaming
	{
	
	}
}

网格资源内存优化
{
	网格资源也是非常常用、重要性不逊于纹理一种资源。它同样和项目的渲染模块CPU、GPU性能有很大关联。本节主要从内存角度探讨网格的顶点数和面片数、顶点属性、Read/Write Enabled......等常见设置对性能的影响。

	Read/Write
	{
		开启后，Unity不仅会把网格数据上传到GPU的内存中，还是在CPU里保留一份，这样系统内存就会有2分网格数据
		关闭后，Unity会把网格数据上传到GPU内存后，从CPU内存中删除对应的网格数据

		需要开启的特殊情况
		{
			开启了Mesh Collider(网格碰撞体)
			游戏中需要使用代码修改模型
		}
	}
		

	顶点属性
	{
		网格的顶点数据有很多种，Position Normal，Tangent(只有法线贴图需要用到)，UV0，UV1
		但是在渲染的时候使用的Shader并不一定用到所有种类的顶点属性，多余的属性就会造成不必要的内存浪费

		Tangent属性可以在Mesh的inspect面板中设置
		Project Settings/Player/Optimize Mesh Data勾选后Unity会自动去掉未使用的顶点属性，可能有bug，最好测试下
	}

	骨骼
	{
		静态物体可以去掉骨骼
	}

	静态合批
	{
		多个小网格合并成一个大网格，内存增加
	}
}


Shader资源内存优化
{
	Shader资源作为一种非常重要的渲染资源，直接影响相关渲染对象和DrawCall的GPU开销。本节主要从内存角度探讨Shader资源内存的控制。

	shader的内存优化主要是从变体上着手，可以通过脚本剔除变体以及手动注释关键字
	shader的变体数量事影响内存占用的重要因素

	脚本剔除变体
	{
		Unity提供IPreprocessShader这个接口，可以继承实现OnProcessShader 去除不必要的变体，可以参考shader变体优化那篇笔记

	}

	手动注释关键字
	{
		明确知道一些关键字不会使用就直接注释掉
	}
}

]==]


--------------------------------------Reserved Unity 内存---------------------------------------------------------

--[==[
Render Texture资源内存优化
{
	Render Texture同样和GPU性能有很大关联。一般而言，如渲染分辨率、抗锯齿、后处理等设置，都可能同时影响GPU性能和内存占用

	抗锯齿
	{
		MSAA开启后，内存增加明显

	}

	阴影分辨率
	{
		移动端1024就够了
	}

	深度
	{
		深度有好几种，0位 16位 24位，不同位数的资源内存也是不同的
		16位比0位大一半
		24位比16位大一半
		24位比0位大一倍

	}

	HDR格式
	{
		HDR有两种格式选择：FP16格式，R11G11B10格式 两种格式占用内存不同
		
		R11G11B10格式： R通道11位数据，G通道11位数据，B通道10位数据，总共32位，所以不使用alpha通道情况下够用
		FP16格式：其实是ARGB Half 格式带有Alpha通道，每个通道用16位数据存储，总共64位数据，内存占用比R11G11B10格式大一倍

		所以在不需要使用alpha通道的情况下尽量先用R11G11B10格式

	}

}




动画资源
{
	动画资源内存占用一般相对较小，但仍要关注其中占用较大、时间却相对短的资源，对动画类型、动画压缩算法、动画精度等因素进行适当调整，在动画表现和内存之间做出合理权衡

	Resample Curves
	{
		Unity默认会对动画开启Resample Curves，把动画曲线重新采样为用四元数表示的曲线，模型导入可以在Animation面板关闭，默认是开启的
		开启后关键帧的数量会变少一些，内存会小点
	}

	动画压缩
	{
		Anim.Compression ==> 可以选择动画的压缩方式
			Keyframe Reduction/Optimal, 压缩有可以显著减少动画的内存占用


		Keyframe Reduction
		{
			减少关键帧数量，可以通过调整error参数来控制压缩的程度（百分数，0.5代表0.5%）
		}

		Optimal
		{
			根据启发算法减少关键帧数量或者改变曲线的存储格式
			
			存储格式：
			{
				Constant (直线，常数) 占用最小
				Dense （无切线）
				Stream （有切线） 占用最大
			}

			使用Optimal压缩的时候会把一部分Stream格式存储的曲线改为用Dense或Constant的格式存储，从而减少内存占用
		}
	}

	剔除Scale曲线
	{
		大部分带有骨骼的动画骨骼的尺寸是不会变的，因此并不需要Scale曲线，可以剔除（但是骨骼动画里都带有scale为1的数据，没有啥意义）
		
		如何剔除
		{
			Unity在导入模型的时候有个选项 Animation选项卡Remove Constant Scale Curve，勾选就可以去掉
			但是这个功能不能去掉所有的scale曲线

			可以使用代码去除， scale数据都是常数，去掉后内存变化不大
		}
	}

	降低精度
	{
		降低精度--曲线变直线--存储格式变成Constant--内存下降

		Unity默认存储每一帧的信息用的是10位精度的Float格式数据，可以用脚本变成3位精度

		单纯降低精度并不会降低内存，因为在内存中每个float占用的大小仍然是一样的，但是降低精度后会是动画曲线发生变化，细微的起伏的曲线就变成直线了
		因此在Optimal的压缩格式下存储格式变成Constant了，降低了内存占用

		需要考虑降低精度后动画的表现效果是否会受影响
	}
}



音频资源





字体资源





粒子系统资源

]==]

